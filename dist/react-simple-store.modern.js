import{useState as t,useEffect as e}from"react";function r(){return r=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var r=arguments[e];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(t[n]=r[n])}return t},r.apply(this,arguments)}const n=(n,o={},s={})=>{let a=!1,i=r({},o);const c=new Set,{allowNested:l=!0}=s,b=(t,e)=>{if(!l&&a)throw new Error("Nested state mutation disabled");try{a=!0;const n="function"==typeof t?t(i):t;if(!Object.is(n,i)){if("object"!=typeof n)throw new Error("next state not object");const t=i;i=e?n:r({},i,n),c.forEach(e=>e(i,t))}}finally{a=!1}},u=()=>i,d=t=>(c.add(t),()=>{c.delete(t)}),f=(t,e,r)=>{let n=t(i);return d(()=>{const o=t(i);(r?r(n,o):Object.is(n,o))||(e(o,n),n=o)})},p=(...t)=>t[1]?f(...t):d(t[0]);return r({},n(b,u,{subscribe:p}),{useStore:(r,n,o)=>{const[{value:s,rebind:a},c]=t({value:r(i),rebind:!(null==o||!o.rebind)});return e(()=>f(r,t=>c({value:t,rebind:a}),n),a?[r]:[]),s},getState:u,setState:b,destroy:()=>c.clear(),subscribe:p})},o=(t,e)=>n((e,r)=>({dispatch:n=>(e(t(r(),n)),n)}),e);export{n as createStore,o as createStoreRedux};
